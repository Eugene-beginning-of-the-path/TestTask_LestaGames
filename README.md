# TestTask

1)
На языке С/С++, написать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути.
Объяснить плюсы и минусы обеих реализаций.

C/C++ example:
bool isEven(int value){return value%2==0;}

Ответ: Для определения четности/нечетности целочисленного числа, я в своей функции использую 
преобразование знакового целочисленного значения из десятичной в двоичную систему счисления.
И основываясь на последнем бите, вовзращается true, если число является четным (на конце
двоичного представления находится нуль), либо же возвращается false, в случае если в 
двоичном представлении числа находится единица.

Для хранения двоичного представления числа использую массив символов std::string. 
Место под которое сразу резервирую максимально возможным кол-вом потребуемых бит.
Это и есть слабое место алгоритма - число, двоичного представление которого может
поместиться в 10 символов строки, оставшаяся выделенная память будет проставивать.

Но это лучше, если бы не было резервации места заранее, наш "capacity", мог бы
быть по стандарту выделен меньше, чем нам необходимо записать символов двоичного 
представления числа, и тогда бы происходил процесс перезаписи массива в новый 
массив, места под непрерывное хранение элементов которого в памяти, было выделено
больше.

Тут так же стоит взять в расчет, что резервацию места под массив символов я 
взял всего 32 байта (по стандарту, под хранения 1 char - 1 байт), что в нынешних 
компьютерныъ условиях, не так уж и много.

2)
На языке С++, написать минимум по 2 класса реализовывающих циклический буфер.
Объяснить плюсы и минусы каждой реализации.

Ответ: В основе написания двух циклических буферов я использовал вектор,
доступ к хранящейся информации которого работает по принципу "стека" и 
"очереди", FILO(First In Last Out) и FIFO(First In First Out) соответственно.

В минусы я отнесу то, что использовал в основе написанны классов вектор, 
элементы которого расположены в памяти беспрерывно. Если элементов в 
буффере будет "много" - будет неоптимизировано последующее добавление 
новых элементов в вектор, т.к. при заполнении выделенного места ("capacity"),
будет происходить перезапись структуры данных, что очень затратно по времени.

3)
На языке С/С++, написать функцию, которая быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел.
Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным).
Объяснить почему вы считаете, что функция соответствует заданным критериям.

Ответ: Изучая алгоритмы и структуры данных, уже не раз сталкивался и 
реализовывал алгоритм сортировки - Merge Sort. Он имеет время выполнения
равное BigO = N*logN. Все благодаря рекурсивной работе алгоритма, 
который разделяет список на двое до тех пор, пока в поделенном
сегменте не окажется 1 или 2 числа, которые выставляются в нужном порядке
и "сливаются" с другим сегментом, так же уже отсортированных чисел.
